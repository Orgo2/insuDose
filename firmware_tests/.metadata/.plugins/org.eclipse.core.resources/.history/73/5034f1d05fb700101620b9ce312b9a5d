#include "tmp102.h"
#include <math.h>

// Helper: convert Celsius to TMP102 12-bit register bytes (MSB, LSB)
static void tmp102_conv_temp_to_bytes(float temp_c, uint8_t *out_msb, uint8_t *out_lsb)
{
    int16_t temp_raw = (int16_t)roundf(temp_c * 16.0f);
    uint16_t raw12 = (uint16_t)temp_raw & 0x0FFF;
    *out_msb = (uint8_t)(raw12 >> 4);
    *out_lsb = (uint8_t)((raw12 & 0x0F) << 4);
}

// Inicializácia TMP102 (voliteľné, môžeš nakonfigurovať režimy ak chceš)
HAL_StatusTypeDef TMP102_Init(I2C_HandleTypeDef *hi2c)
{
    // TMP102 je pripravený ihneď po napájaní.
    // Voliteľne by si mohol nastaviť konfiguráciu, ale default je OK.
    return HAL_OK;
}

// Čítanie teploty
HAL_StatusTypeDef TMP102_ReadTemperature(I2C_HandleTypeDef *hi2c, float *temperature_celsius)
{
    uint8_t buffer[2];
    uint8_t reg_pointer = 0x00; // Pointer na Temperature Register
    HAL_StatusTypeDef ret;

    // Nastav pointer na temperature register
    ret = HAL_I2C_Master_Transmit(hi2c, TMP102_I2C_ADDRESS, &reg_pointer, 1, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }

    // Prečítaj 2 bajty
    ret = HAL_I2C_Master_Receive(hi2c, TMP102_I2C_ADDRESS, buffer, 2, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }


    // Spracovanie údajov
    uint16_t raw_temp = (buffer[0] << 4) | (buffer[1] >> 4);

    // Ak je teplota záporná, rozšíriť znamienko
    if (raw_temp & 0x800) {
        raw_temp |= 0xF000;
    }

    // Prevod na °C
    *temperature_celsius = raw_temp * 0.0625f;

    return HAL_OK;
}

// Zapíše prahovú hodnotu T_HIGH (alarm) v °C do TMP102 senzora.
// Poznámka: funkcia iba zapíše registr T_HIGH; správanie výstupu ALERT
// (komparátor vs interrupt, polarita, atď.) závisí od konfiguračného registra.
HAL_StatusTypeDef TMP102_EnableAlarm(I2C_HandleTypeDef *hi2c, float temp_celsius)
{
    if (hi2c == NULL) {
        return HAL_ERROR;
    }

    // Konverzia °C na 12-bitový formát TMP102 (LSB = 0.0625 = 1/16)
    // Použijeme zaokrúhlenie na najbližší 1/16°C.
    int16_t temp_raw = (int16_t)roundf(temp_celsius * 16.0f);

    // TMP102 používa 12-bit two's complement hodnotu umiestnenú v bitoch [15:4]
    // Pri záporných hodnotách využijeme maskovanie na 12 bitov.
    uint16_t raw12 = (uint16_t)temp_raw & 0x0FFF;

    // Priprav bajty pre zápis: najprv pointer register (T_HIGH = 0x03), potom MSB, LSB
    uint8_t tx[3];
    tx[0] = TMP102_REG_T_HIGH;
    tx[1] = (uint8_t)(raw12 >> 4);            // horných 8 bitov
    tx[2] = (uint8_t)((raw12 & 0x0F) << 4);  // dolné 4 bity posunuté do MSB nibble

    HAL_StatusTypeDef ret = HAL_I2C_Master_Transmit(hi2c, TMP102_I2C_ADDRESS, tx, 3, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }

    return HAL_OK;
}

// Nastaví oba prahy (T_LOW a T_HIGH) a konfiguruje TMP102 do comparator režimu
// s nízkou spotrebou. Funkcia zapne napájanie cez PW_TMP pin, počká na štart
// senzora, zapíše T_LOW a T_HIGH a nastaví konfiguráciu.
HAL_StatusTypeDef TMP102_SetAlarm(I2C_HandleTypeDef *hi2c, float t_low_c, float t_high_c, uint8_t fault_count)
{
    if (hi2c == NULL) {
        return HAL_ERROR;
    }

    HAL_StatusTypeDef ret;

    // 1) Zapni napájanie senzora cez definovaný pin PW_TMP
    HAL_GPIO_WritePin(PW_TMP_GPIO_Port, PW_TMP_Pin, GPIO_PIN_SET);

    // 2) Počkajúci čas na stabilizáciu senzora (typicky 250 ms)
    HAL_Delay(250);

    // 3) Zapiš T_LOW
    uint8_t tx_low[3];
    tx_low[0] = TMP102_REG_T_LOW;
    tmp102_conv_temp_to_bytes(t_low_c, &tx_low[1], &tx_low[2]);

    ret = HAL_I2C_Master_Transmit(hi2c, TMP102_I2C_ADDRESS, tx_low, 3, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }

    // 5) Zapiš T_HIGH
    uint8_t tx_high[3];
    tx_high[0] = TMP102_REG_T_HIGH;
    tmp102_conv_temp_to_bytes(t_high_c, &tx_high[1], &tx_high[2]);

    ret = HAL_I2C_Master_Transmit(hi2c, TMP102_I2C_ADDRESS, tx_high, 3, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }

    // 6) Priprav konfiguraciu
    // Mapovanie fault_count -> F1 F0: 1->00, 2->01, 4->10, 6->11. Default = 4.
    uint8_t f1 = 1;
    uint8_t f0 = 0;
    if (fault_count == 1) { f1 = 0; f0 = 0; }
    else if (fault_count == 2) { f1 = 0; f0 = 1; }
    else if (fault_count == 4) { f1 = 1; f0 = 0; }
    else if (fault_count == 6) { f1 = 1; f0 = 1; }
    else { /* default to 4 */ f1 = 1; f0 = 0; }

    // Byte1 bits: OS R1 R0 F1 F0 POL TM SD
    // Set R1/R0 to 1/1 (per datasheet converter resolution default),
    // OS=0, POL=0 (active low), TM=0 (comparator), SD=0 (continuous conversion)
    uint8_t cfg_byte1 = 0;
    cfg_byte1 |= (0 << 7); // OS
    cfg_byte1 |= (1 << 6); // R1 (read-only)
    cfg_byte1 |= (1 << 5); // R0 (read-only)
    cfg_byte1 |= (f1 << 4);
    cfg_byte1 |= (f0 << 3);
    cfg_byte1 |= (0 << 2); // POL = 0 -> active low
    cfg_byte1 |= (0 << 1); // TM = 0 -> Comparator mode
    cfg_byte1 |= (0 << 0); // SD = 0 -> continuous conversion

    // Byte2 bits: CR1 CR0 AL EM 0 0 0 0
    // Set CR to 00 for 0.25 Hz (lowest conversion rate) to save power
    // AL is read-only, EM=0 (normal 12-bit mode)
    uint8_t cfg_byte2 = 0;
    cfg_byte2 |= (0 << 7); // CR1
    cfg_byte2 |= (0 << 6); // CR0
    cfg_byte2 |= (0 << 4); // EM = 0

    uint8_t tx_cfg[3];
    tx_cfg[0] = TMP102_REG_CONFIG;
    tx_cfg[1] = cfg_byte1;
    tx_cfg[2] = cfg_byte2;

    ret = HAL_I2C_Master_Transmit(hi2c, TMP102_I2C_ADDRESS, tx_cfg, 3, HAL_MAX_DELAY);
    if (ret != HAL_OK) {
        return ret;
    }

    // Krátka pauza po zapise konfiguracie
    HAL_Delay(10);

    return HAL_OK;
}